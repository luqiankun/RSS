<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TCS_view</title>
    <script type="application/javascript">
        class Queue {
            constructor() {
                this.items = {};
                this.headIndex = 0;
                this.tailIndex = 0;
            }

            enqueue(item) {
                this.items[this.tailIndex] = item;
                this.tailIndex++;
            }

            dequeue() {
                const item = this.items[this.headIndex];
                delete this.items[this.headIndex];
                this.headIndex++;
                return item;
            }

            peek() {
                return this.items[this.headIndex];
            }
            get length() {
                return this.tailIndex - this.headIndex;
            }
        }
        class Point {
            constructor(name, x, y, t) {
                this.name = name;
                this.x = x;
                this.y = y;
                this.type = t
            }
        }
        class Path {
            constructor(name, start, end, max_vel, max_res_vel) {
                this.name = name;
                this.start = start;
                this.end = end;
                this.locked = false;
                this.max_vel = max_vel;
                this.max_res_vel = max_res_vel;
            }
        }
        class Location {
            constructor(name, x, y, link, t) {
                this.name = name;
                this.x = x;
                this.y = y;
                this.link = link;
                this.locked = false;
                this.type = t;
            }
        }
        class Vehicle {
            constructor(name, x, y, level, envelope) {
                this.name = name;
                this.x = x;
                this.y = y;
                this.color = "#891111";
                this.step = [];
                this.destination = {};
                this.battery = level
                this.envelope = envelope
            }
        }
        class Block {
            constructor(obj) {
                this.name = obj["name"];
                this.color = obj["layout"]["color"];
                this.member = [];
                for (let x of obj['memberNames']) {
                    let v = {};
                    v['name'] = x["name"];
                    this.member.push(v);
                }
            }
        }
        let points = [];
        let paths = [];
        let locations = [];
        let vehicles = [];
        let blocks = [];
        let orders = new Map();
        let order_quence = new Queue();
        let xmin = 0;
        let xman = 0;
        let ymin = 0;
        let yman = 0;
        let delta_x = 0;
        let delta_y = 0;
        let resolution = 50;
        let is_running = false;
        let mouse_flag = false;
        let mouse_2_flag = false;
        let last_mouse_x = 0;
        let last_mouse_y = 0;
        let last_delta_x = 0;
        let last_delta_y = 0;
        let select_vehicle = ''
        let timer_draw_vehlice = setInterval(() => {
            clearInterval(timer_draw_vehlice);
        }, 500)
        function add_wheel(ctx) {
            let canvas = document.getElementById(ctx);
            canvas.addEventListener('wheel', function (event) {
                let deltaY = event.deltaY;
                if (is_running) {
                    event.preventDefault();
                    //放缩分辨率
                    if (deltaY > 0) {
                        resolution += 5;
                        clicked();

                    } else if (deltaY < 0) {
                        resolution -= 5;
                        clicked();
                    }
                }

            });
        }
        function format(date) {
            if (!date) return;
            var date2 = new Date(date);
            var y = date2.getUTCFullYear();
            var m = date2.getMonth() + 1;
            m = m < 10 ? "θ" + m : m;
            var d = date2.getDate();
            d = d < 10 ? "θ" + d : d;
            var h = date2.getHours();
            h = h < 10 ? "θ" + h : h;
            var minute = date2.getMinutes();
            minute = minute < 10 ? "0" + minute : minute;
            var sec = date2.getSeconds();
            sec = sec < 10 ? "0" + sec : sec
            var mseconds = date2.getMilliseconds(); //获取当前毫秒数（0 - 999）
            mseconds = mseconds < 10 ? "0" + mseconds : mseconds;
            return y + "-" + m + "-" + d + "T" + h + ":" + minute + ":" + sec + "." + mseconds + "Z";
        }
        function order(veh, dest, op) {
            ord = {
                "incompleteName": false,
                "dispensable": false,
                "deadline": "2028-01-31T18:42:40.396Z",
                "intendedVehicle": veh,
                "peripheralReservationToken": "Token-001",
                "wrappingSequence": "OrderSequence-0001",
                "type": op,
                "destinations": [
                    {
                        "locationName": dest,
                        "operation": op,
                        "properties": [
                        ]
                    }
                ],
                "properties": [
                ],
                "dependencies": [
                ]
            }
            return ord;
        }
        function add_mouse(ctx) {
            document.querySelector("body").style.cursor = "grab"
            let canvas = document.getElementById(ctx);
            canvas.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                e.stopPropagation();
            })
            canvas.addEventListener('mouseup', (event) => {
                if (mouse_flag) {
                    if (event.button == 0) {
                        mouse_flag = false
                        document.querySelector("body").style.cursor = "grab"
                        for (const point of points) {
                            let x = (point.x - xmin) / resolution;
                            let y = canvas.height - (point.y - ymin) / resolution;
                            if (Math.abs(x - event.offsetX) < 15 && Math.abs(y - event.offsetY) < 15) {
                                // console.log(order(select_vehicle, point.name, "MOVE"))
                                let Http = new XMLHttpRequest();
                                let ip = document.getElementById("ip_btn").value;
                                Http.open('POST', 'http://' + ip + '/v1/transportOrders/Torder_' + format(new Date().getTime()), true);
                                Http.onload = function () {
                                    if (Http.readyState == 4 && Http.status == 200) {
                                        console.log("send order ok");
                                    }
                                    else {
                                        console.log("send order err");
                                    }
                                }
                                Http.send(JSON.stringify(order(select_vehicle, point.name, "MOVE")))
                                return;
                            }
                        }
                        for (const loc of locations) {
                            let x = (loc.x - xmin) / resolution;
                            let y = canvas.height - (loc.y - ymin) / resolution;
                            if (Math.abs(x - event.offsetX) < 20 && Math.abs(y - event.offsetY) < 20) {
                                let Http = new XMLHttpRequest();
                                let ip = document.getElementById("ip_btn").value;
                                Http.open('POST', 'http://' + ip + '/v1/transportOrders/Torder_' + format(new Date().getTime()), true);
                                Http.onload = function () {
                                    if (Http.readyState == 4 && Http.status == 200) {
                                        console.log("send order ok");
                                    }
                                    else {
                                        console.log("send order err");
                                    }
                                }
                                Http.send(JSON.stringify(order(select_vehicle, loc.name, "pick")))
                                return;
                            }
                        }
                    }
                    // console.log("-------", format(new Date().getTime()))
                }
                if (mouse_2_flag) {
                    if (event.button == 2) {
                        mouse_2_flag = false
                        document.querySelector("body").style.cursor = "grab"
                    }
                }
            });
            canvas.addEventListener('mousedown', (event) => {
                if (event.button == 0) {
                    //左键
                    for (const veh of vehicles) {
                        let x = (veh.x - xmin) / resolution;
                        let y = canvas.height - (veh.y - ymin) / resolution;
                        if (Math.abs(x - event.offsetX) < 15 && Math.abs(y - event.offsetY) < 15) {
                            mouse_flag = true;
                            select_vehicle = veh.name
                            document.querySelector("body").style.cursor = "pointer"

                            // console.log('□□□□□□□□')
                            return
                        }
                    }
                    document.querySelector("body").style.cursor = "crosshair"
                } else if (event.button == 2) {
                    //右键
                    mouse_2_flag = true;
                    last_mouse_x = event.offsetX
                    last_mouse_y = event.offsetY
                    last_delta_x = delta_x
                    last_delta_y = delta_y
                    document.querySelector("body").style.cursor = "grabbing"

                }
            });
            canvas.addEventListener('mousemove', (event) => {
                if (!is_running) return
                if (!mouse_flag) {
                    let ctx = canvas.getContext("2d");
                    for (const veh of vehicles) {
                        let x = (veh.x - xmin) / resolution;
                        let y = canvas.height - (veh.y - ymin) / resolution;
                        if (Math.abs(x - event.offsetX) < 15 && Math.abs(y - event.offsetY) < 15) {
                            ctx.font = '20px Arial';
                            ctx.fillStyle = "red";
                            ctx.textBaseline = "alphabetic";
                            ctx.fillText(veh.name, x + 10, y + 23, veh.name.length * 20);
                            return
                        }
                    }
                    for (const point of points) {
                        let x = (point.x - xmin) / resolution;
                        let y = canvas.height - (point.y - ymin) / resolution;
                        if (Math.abs(x - event.offsetX) < 15 && Math.abs(y - event.offsetY) < 15) {
                            ctx.font = '20px Arial';
                            ctx.fillStyle = "red";
                            ctx.textBaseline = "alphabetic";
                            ctx.fillText(point.name, x + 10, y + 23, point.name.length * 20);
                            return;
                        }
                    }
                    for (const loc of locations) {
                        let x = (loc.x - xmin) / resolution;
                        let y = canvas.height - (loc.y - ymin) / resolution;
                        if (Math.abs(x - event.offsetX) < 15 && Math.abs(y - event.offsetY) < 15) {
                            ctx.font = '20px Arial';
                            ctx.fillStyle = "red";
                            ctx.textBaseline = "alphabetic";
                            ctx.fillText(loc.name, x + 10, y + 23, loc.name.length * 20);
                            return;
                        }
                    }
                }
                if (mouse_2_flag) {
                    //move
                    let move_x = event.offsetX - last_mouse_x;
                    let move_y = event.offsetY - last_mouse_y;
                    delta_x = last_delta_x - resolution * move_x
                    delta_y = last_delta_y + resolution * move_y
                    clicked();
                }

            });
            canvas.addEventListener('dblclick', (event) => {
                if (!is_running) return
                if (event.button == 0) {
                    let m_x = event.offsetX
                    let m_y = event.offsetY
                    for (const path of paths) {
                        let st = get_point(path.start)
                        let st_x = (st.x - xmin) / resolution
                        let st_y = canvas.height - (st.y - ymin) / resolution
                        let ed = get_point(path.end)
                        let ed_x = (ed.x - xmin) / resolution
                        let ed_y = canvas.height - (ed.y - ymin) / resolution
                        let dist_st = Math.sqrt((m_x - st_x) * (m_x - st_x) + (m_y - st_y) * (m_y - st_y))
                        let dist_ed = Math.sqrt((m_x - ed_x) * (m_x - ed_x) + (m_y - ed_y) * (m_y - ed_y))
                        let dist_se = Math.sqrt((st_x - ed_x) * (st_x - ed_x) + (st_y - ed_y) * (st_y - ed_y))
                        if (dist_ed > dist_se) {
                            continue
                        }
                        if (dist_st > dist_se) {
                            continue
                        }
                        //
                        let p = (dist_se + dist_ed + dist_st) / 2;
                        let S = Math.sqrt(p * (p - dist_ed) * (p - dist_se) * (p - dist_st));
                        let h = 2 * S / dist_se;
                        if (h < 5 && dist_st > 5 && dist_ed > 5) {
                            let req = new XMLHttpRequest()
                            let url = "/v1/paths/" + path.name + "/locked?"
                            let queryParams = "newValue=";
                            if (path.locked) {
                                queryParams += "false"
                            } else {
                                queryParams += "true"
                            }
                            url += queryParams;
                            let ip = document.getElementById("ip_btn").value;
                            req.open('PUT', "http://" + ip + url, true)
                            req.onload = function () {
                                if (req.readyState == 4 && req.status == 200) {
                                    // console.log("send order ok");
                                    clicked()
                                }
                                else {
                                    console.log("send order err");
                                }
                            }
                            req.send()
                            // console.log('▲▲▲▲▲▲▲', path.name, dist_st, dist_ed, dist_se)
                        }

                    }
                    for (const loc of locations) {
                        let x = (loc.x - xmin) / resolution
                        let y = canvas.height - (loc.y - ymin) / resolution
                        let dist = Math.sqrt((x - m_x) * (x - m_x) + (y - m_y) * (y - m_y))
                        if (dist < 5) {
                            let req = new XMLHttpRequest()
                            let url = "/v1/locations/" + loc.name + "/locked?"
                            let queryParams = "newValue=";
                            if (loc.locked) {
                                queryParams += "false"
                            } else {
                                queryParams += "true"
                            }
                            url += queryParams;
                            let ip = document.getElementById("ip_btn").value;
                            req.open('PUT', "http://" + ip + url, true)
                            req.onload = function () {
                                if (req.readyState == 4 && req.status == 200) {
                                    // console.log("send order ok");
                                    clicked()
                                }
                                else {
                                    console.log("send order err");
                                }
                            }
                            req.send()
                        }

                    }
                }
            })
        }
        function get_img_limit() {
            let x_min = 9999999;
            let x_max = -9999999;
            let y_min = 9999999;
            let y_max = -9999999;
            for (let x of points) {
                if (x.x < x_min) {
                    x_min = x.x;
                }
                if (x.x > x_max) {
                    x_max = x.x;
                }
                if (x.y < y_min) {
                    y_min = x.y;
                }
                if (x.y > y_max) {
                    y_max = x.y;
                }
            }
            for (let x of locations) {
                if (x.x < x_min) {
                    x_min = x.x;
                }
                if (x.x > x_max) {
                    x_max = x.x;
                }
                if (x.y < y_min) {
                    y_min = x.y;
                }
                if (x.y > y_max) {
                    y_max = x.y;
                }
            }
            xmin = x_min - 5000 + delta_x;
            xman = x_max + 5000 + delta_x;
            ymin = y_min - 5000 + delta_y;
            yman = y_max + 5000 + delta_y;
        }

        function get_block_path(name) {
            for (let x of paths) {
                if (name == x.name) {
                    return x;
                }
            }
            return null;
        }

        function get_block_point(name) {
            for (let x of points) {
                if (name == x.name) {
                    return x;
                }
            }
            return null;
        }

        function get_point(name) {
            for (let x of points) {
                if (x.name == name) {
                    return x;
                }
            }
            return null
        }
        function get_location(name) {
            for (let x of locations) {
                if (x.name == name) {
                    return x;
                }
            }
            return null
        }
        function get_model() {
            if (is_running) {
                is_running = false;
                clearInterval(timer_draw_vehlice);
                document.getElementById('stop_btn').style.display = 'none';
                document.getElementById('ok_btn').style.display = '';
            }
            let Http = new XMLHttpRequest();
            let ip = document.getElementById("ip_btn").value;
            let pattern = new RegExp("^((25[0-5]|2[0-4]\\d|1\\d{2}|[1-9]\\d|\\d)\\.){3}(25[0-5]|2[0-4]\\d|1\\d{2}|[1-9]\\d|\\d):([1-9]|[1-9]\\d{1,3}|[1-6][0-5][0-5][0-3][0-5])$")
            if (!pattern.test(ip)) {
                alert("请输入正确的ip格式-> ip:port")
                // console.log(ip)
                unconnect('map');
                unconnect('Vehicle');
                unconnect('Order');
                orders.clear();
                document.getElementById('ip_btn').value = "";
                return
            }
            Http.open('GET', 'http://' + ip + '/v1/plantModel', true);
            // console.log('http://' + ip + '/plantModel')
            Http.withCredentials = false;
            Http.onload = function () {
                if (Http.readyState == 4 && Http.status == 200) {
                    points = [];
                    paths = [];
                    locations = []
                    orders.clear();
                    let model = JSON.parse(Http.responseText);
                    // console.log(model);
                    for (let point of model["points"]) {
                        let x = point["layout"]["position"]["x"];
                        let y = point["layout"]["position"]["y"];
                        let name = point["name"];
                        let t = point["type"]
                        let p = new Point(name, x, y, t);
                        points.push(p);
                    }
                    for (let path of model["paths"]) {
                        let end = path["destPointName"];
                        let start = path["srcPointName"]
                        let locked = path["locked"];
                        let name = path["name"];
                        let max_vel = path['maxVelocity']
                        let max_res_vel = path["maxReverseVelocity"]
                        let p = new Path(name, start, end, max_vel, max_res_vel);
                        p.locked = locked;
                        paths.push(p);
                    }
                    for (let loc of model["locations"]) {
                        let x = loc["layout"]["position"]["x"];
                        let y = loc["layout"]["position"]["y"];
                        let name = loc["name"];
                        let locked = loc["locked"];
                        let link = loc["links"][0] ? loc["links"][0]["pointName"] : null
                        let type = loc["typeName"]
                        let p = new Location(name, x, y, link, type);
                        p.locked = locked;
                        locations.push(p);
                    }
                    for (let block of model["blocks"]) {
                        let b = new Block(block);
                        blocks.push(b);
                    }
                    get_img_limit();
                    // console.log('-------------', model_has)
                    draw_map();
                    is_running = true
                    document.getElementById('stop_btn').style.display = '';
                    document.getElementById('ok_btn').style.display = 'none';
                    document.getElementById('ip_btn').setAttribute('disabled', 'disabled')

                    timer_draw_vehlice = setInterval(() => {
                        get_view();
                        draw_vehicle();
                        get_order();
                        draw_order();
                    }, 300)
                }
                else {
                    console.log("get model failed");
                }
            }
            Http.onerror = function (e) {
                alert("请求失败,检查服务器地址和请求参数")
                unconnect('map');
                unconnect('Vehicle');
                unconnect('Order');

            }
            Http.onloadstart = function () {
                // console.log("start request")
            }
            Http.onloadend = function () {
                // console.log("request end")
            }
            Http.onabort = function () {
                console.log("request failed")
            }
            Http.send();
        }
        function get_view() {
            let Http = new XMLHttpRequest();
            let ip = document.getElementById("ip_btn").value;
            let pattern = new RegExp("^((25[0-5]|2[0-4]\\d|1\\d{2}|[1-9]\\d|\\d)\\.){3}(25[0-5]|2[0-4]\\d|1\\d{2}|[1-9]\\d|\\d):([1-9]|[1-9]\\d{1,3}|[1-6][0-5][0-5][0-3][0-5])$")
            let reg = new RegExp(pattern)
            if (!reg.test(ip)) {
                document.getElementById('ip_btn').value = "";
                return
            }
            Http.open('GET', 'http://' + ip + '/v1/getView', true);
            Http.withCredentials = false;
            Http.onload = function () {
                if (Http.readyState == 4 && Http.status == 200) {
                    vehicles = [];
                    let model = JSON.parse(Http.responseText);
                    for (let v of model) {
                        let veh = new Vehicle(v["name"], v["position"]["x"], v["position"]["y"], v["battery_level"], v["envelope"]);
                        veh.color = v["color"];
                        // console.log(v["step"]);
                        veh.step = v["step"];
                        veh.destination = v["destination"]
                        vehicles.push(veh);
                    }
                }
            }
            Http.onerror = function (e) {
                // console.log(e);
            }
            // Http.onloadstart = function () {
            //     console.log("start request")
            // }
            // Http.onloadend = function () {
            //     console.log("request end")
            // }
            // Http.onabort = function () {
            //     console.log("request failed")
            // }
            Http.send();
        }
        function get_order() {
            let Http = new XMLHttpRequest();
            let ip = document.getElementById("ip_btn").value;

            Http.open('GET', 'http://' + ip + '/v1/transportOrders', true);
            Http.withCredentials = false;
            Http.onload = function () {
                if (Http.readyState == 4 && Http.status == 200) {
                    let model = JSON.parse(Http.responseText);
                    for (let order of model) {
                        if (orders.has(order["name"])) {
                            // console.log(a, b, a === b)
                            if (orders.get(order["name"]) != order["state"]) {
                                //update
                                console.log(orders.get(order["name"]), order["state"])
                                orders.set(order["name"], order["state"]);
                                for (let i = order_quence.headIndex; i < order_quence.tailIndex; i++) {
                                    if (order_quence.items[i][0] == order["name"]) {
                                        order_quence.items[i][1] = order["state"];
                                        break
                                    }
                                }
                                while (order_quence.length > 5) {
                                    order_quence.dequeue();
                                }
                            } else { }
                        }
                        else {
                            orders.set(order["name"], order["state"]);
                            order_quence.enqueue([order["name"], order["state"]]);
                            while (order_quence.length > 5) {
                                order_quence.dequeue();
                            }
                        }
                    }
                }
            }
            Http.onerror = function (e) {
                // console.log(e);
            }
            Http.send();
        }
        function drawArrowhead(ctx, x1, y1, x2, y2, size, color) {
            let l = 10 * (50 / resolution); // 
            let a = Math.atan2((y2 - y1), (x2 - x1));
            let x3 = x2 - l * Math.cos(a + 30 * Math.PI / 180); // θ=30
            let y3 = y2 - l * Math.sin(a + 30 * Math.PI / 180);
            let x4 = x2 - l * Math.cos(a - 30 * Math.PI / 180);
            let y4 = y2 - l * Math.sin(a - 30 * Math.PI / 180);
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.moveTo(x3, y3);
            ctx.lineTo(x2, y2);
            ctx.lineTo(x4, y4);
            ctx.lineWidth = size;
            ctx.strokeStyle = color;
            ctx.stroke();
        }
        function start() {
            // add_wheel('map')
            add_wheel('Vehicle')
            add_mouse('Vehicle')
            unconnect('map');
            unconnect('Order');
            unconnect('Vehicle');
            document.getElementById('stop_btn').style.display = 'none';
            document.getElementById('ok_btn').style.display = '';
            window.onresize = (e) => {
                if (is_running) { clicked(); }
            }
        }
        function draw_map() {
            let canvas = document.getElementById("map");
            // canvas.width = (xman - xmin) / resolution
            // canvas.height = (yman - ymin) / resolution
            canvas.width =
                document.body.clientWidth - 40;
            canvas.height = document.documentElement.clientHeight - 200
            if (canvas.getContext) {
                let ctx = canvas.getContext("2d");
                // console.log(canvas.width + " " + canvas.height + " " + points.length)
                ctx.beginPath()
                ctx.fillStyle = "rgb(10,10,10)";
                ctx.strokeRect(0, 0, canvas.width, canvas.height);
                for (let point of points) {
                    let x = (point.x - xmin) / resolution;
                    let y = canvas.height - (point.y - ymin) / resolution;
                    let radius = 8 * (50 / resolution);
                    ctx.beginPath()
                    ctx.fillStyle = "rgb(0,0,0)";
                    ctx.strokeStyle = 'black'
                    ctx.moveTo(x + radius, y);
                    ctx.lineWidth = 3 * (50 / resolution);
                    if (ctx.lineWidth < 1) {
                        ctx.lineWidth = 1;
                    }
                    ctx.arc(x, y, radius, 0, 2 * Math.PI, true)
                    if (point.type == "PARK_POSITION") {
                        ctx.arc(x, y, radius + 3, 0, 2 * Math.PI, true)
                    }
                    ctx.stroke()
                    let font_size = (13 * (50 / resolution)).toFixed(0);
                    if (font_size < 1) {
                        font_size = 1;
                    }
                    ctx.font = font_size.toString() + 'px Arial';
                    ctx.fillStyle = "black";
                    ctx.textBaseline = "top";
                    ctx.fillText(point.name, x + 10 * (50 / resolution), y + 23 * (50 / resolution), point.name.length * font_size);
                }
                for (let x of paths) {
                    color = 'orange'
                    if (x.locked) {
                        color = "rgba(102, 102, 102, 0.3)"
                    }
                    let start = get_point(x.start);
                    let end = get_point(x.end);
                    // console.log(x["name"], start["name"], end["name"]);
                    let start_x = (start.x - xmin) / resolution;
                    let start_y = canvas.height - (start.y - ymin) / resolution;
                    let end_x = (end.x - xmin) / resolution;
                    let end_y = canvas.height - (end.y - ymin) / resolution;
                    // console.log(start_x, start_y, end_x, end_y);

                    let len = Math.sqrt((end_x - start_x) * (end_x - start_x) + (end_y - start_y) * (end_y - start_y))
                    // console.log(len);
                    let norm_x = (end_x - start_x) / len;
                    let norm_y = (end_y - start_y) / len;
                    start_x = start_x + norm_x * 15 * (50 / resolution);;
                    start_y = start_y + norm_y * 15 * (50 / resolution);;
                    end_x = end_x - norm_x * 15 * (50 / resolution);;
                    end_y = end_y - norm_y * 15 * (50 / resolution);;
                    if (x.max_vel) { drawArrowhead(ctx, start_x, start_y, end_x, end_y, 1 * (50 / resolution), color); }
                    if (x.max_res_vel) { drawArrowhead(ctx, end_x, end_y, start_x, start_y, 1 * (50 / resolution), color); }
                }

                for (let x_ of blocks) {
                    for (let p of x_['member']) {
                        let point = get_block_point(p['name']);
                        if (point != null) {
                            let x = (point.x - xmin) / resolution;
                            let y = canvas.height - (point.y - ymin) / resolution;
                            let radius = 5 * (50 / resolution);
                            ctx.beginPath()
                            ctx.fillStyle = x_.color;
                            ctx.strokeStyle = x_.color;
                            ctx.moveTo(x + radius, y);
                            ctx.lineWidth = 3 * (50 / resolution);
                            if (ctx.lineWidth < 1) {
                                ctx.lineWidth = 1;
                            }
                            ctx.arc(x, y, radius, 0, 2 * Math.PI, true)
                            ctx.fill();
                            let font_size = (13 * (50 / resolution)).toFixed(0);
                            if (font_size < 1) {
                                font_size = 1;
                            }
                            ctx.font = font_size.toString() + 'px Arial';
                            ctx.fillStyle = x_.color;
                            ctx.textBaseline = "top";
                            ctx.fillText(point.name, x + 10 * (50 / resolution), y + 23 * (50 / resolution), point.name.length * font_size);
                        }
                        path = get_block_path(p['name']);
                        if (path != null) {
                            if (path.locked) {
                                continue
                            }
                            let start = get_point(path.start);
                            let end = get_point(path.end);
                            // console.log(x["name"], start["name"], end["name"]);
                            let start_x = (start.x - xmin) / resolution;
                            let start_y = canvas.height - (start.y - ymin) / resolution;
                            let end_x = (end.x - xmin) / resolution;
                            let end_y = canvas.height - (end.y - ymin) / resolution;
                            // console.log(start_x, start_y, end_x, end_y);

                            let len = Math.sqrt((end_x - start_x) * (end_x - start_x) + (end_y - start_y) * (end_y - start_y))
                            // console.log(len);
                            let norm_x = (end_x - start_x) / len;
                            let norm_y = (end_y - start_y) / len;
                            start_x = start_x + norm_x * 15 * (50 / resolution);
                            start_y = start_y + norm_y * 15 * (50 / resolution);
                            end_x = end_x - norm_x * 15 * (50 / resolution);
                            end_y = end_y - norm_y * 15 * (50 / resolution);
                            if (path.max_vel) { drawArrowhead(ctx, start_x, start_y, end_x, end_y, 1 * (50 / resolution), x_.color); }
                            if (path.max_res_vel) { drawArrowhead(ctx, end_x, end_y, start_x, start_y, 1 * (50 / resolution), x_.color); }

                        }
                    }


                }

                for (let loc of locations) {
                    color = '#233bc2'
                    if (loc.locked) {
                        color = "rgba(102, 102, 102, 0.3)"
                    }
                    let start_x = (loc.x - xmin) / resolution;
                    let start_y = canvas.height - (loc.y - ymin) / resolution;
                    ctx.beginPath()
                    ctx.lineWidth = 1 * (50 / resolution);
                    if (ctx.lineWidth < 1) {
                        ctx.lineWidth = 1;
                    }
                    let radius = 5 * (50 / resolution)
                    ctx.strokeStyle = color
                    ctx.moveTo(start_x + radius, start_y);
                    ctx.arc(start_x, start_y, radius, 0, 2 * Math.PI, true)
                    ctx.stroke()
                    ctx.lineWidth = 2 * (50 / resolution);
                    if (loc.type == "charge") {
                        ctx.arc(start_x, start_y, radius + 3, 0, 2 * Math.PI, true)
                    } else if (loc.type == "LIFT") {
                        ctx.strokeRect(start_x - 8, start_y - 8, 16, 16);
                    }
                    ctx.stroke()
                    ctx.lineWidth = 1 * (50 / resolution);
                    ctx.strokeRect(start_x - 25 * (50 / resolution), start_y - 15 * (50 / resolution), 50 * (50 / resolution), 30 * (50 / resolution));
                    let link = get_point(loc.link);
                    if (link == null) {
                        continue
                    }
                    let link_x = (link.x - xmin) / resolution;
                    let link_y = canvas.height - (link.y - ymin) / resolution;
                    let len = Math.sqrt((link_x - start_x) * (link_x - start_x) + (link_y - start_y) * (link_y - start_y));
                    let norm_x = (link_x - start_x) / len;
                    let norm_y = (link_y - start_y) / len;
                    start_x = start_x + norm_x * 10 * (50 / resolution);
                    start_y = start_y + norm_y * 10 * (50 / resolution);
                    link_x = link_x - norm_x * 10 * (50 / resolution);
                    link_y = link_y - norm_y * 10 * (50 / resolution);
                    ctx.beginPath()
                    ctx.strokeStyle = '#909090'
                    ctx.moveTo(start_x, start_y);
                    ctx.lineTo(link_x, link_y)
                    ctx.stroke()
                    let font_size = (13 * (50 / resolution)).toFixed(0);
                    ctx.font = font_size.toString() + 'px Arial';
                    ctx.fillStyle = "black";
                    ctx.textBaseline = "top";
                    ctx.fillText(loc.name, start_x - 35 * (50 / resolution), start_y - 43 * (50 / resolution), loc.name.length * font_size);
                }
            }
        }

        function unconnect(ctx) {
            let canvas = document.getElementById(ctx);
            canvas.width =
                document.body.clientWidth - 40;
            canvas.height = document.documentElement.clientHeight - 200
            if (canvas.getContext) {
                let context = canvas.getContext("2d");
                context.font = '40px Arial';
                context.fillStyle = '#04AA6D';
                context.textBaseline = 'top';
                context.textAlign = 'center'
                context.fillText("未连接", canvas.width / 2, canvas.height / 2, 200);
            }
        }

        function draw_order() {
            let canvas = document.getElementById("Order");
            // canvas.width = (xman - xmin) / resolution
            // canvas.height = (yman - ymin) / resolution
            canvas.width =
                document.body.clientWidth - 40;
            canvas.height = document.documentElement.clientHeight - 200
            if (canvas.getContext) {
                let ctx = canvas.getContext("2d");
                let index = 20;
                for (let i = order_quence.headIndex; i < order_quence.tailIndex; i++) {
                    msg = order_quence.items[i][0] + " : [" + order_quence.items[i][1] + "]";
                    ctx.fillStyle = "rgba(113, 125, 126,0.3)";
                    let font_size = (20 * (resolution / 50)).toFixed(0);
                    if (font_size < 1) {
                        font_size = 1;
                    }
                    let y = index;
                    index += 25 * resolution / 50;
                    ctx.font = font_size.toString() + 'px Arial';
                    ctx.textBaseline = "top";
                    ctx.textAlign = 'right';
                    ctx.fillText(msg, canvas.width - 5, y, ctx.measureText(msg).width);
                }
            }
        }
        function draw_vehicle() {
            let canvas = document.getElementById("Vehicle");
            // canvas.width = (xman - xmin) / resolution
            // canvas.height = (yman - ymin) / resolution
            canvas.width =
                document.body.clientWidth - 40;
            canvas.height = document.documentElement.clientHeight - 200
            if (canvas.getContext) {
                let ctx = canvas.getContext("2d");

                // console.log(canvas.width, canvas.height)
                for (let v of vehicles) {
                    // console.log(v);
                    let x = (v.x - xmin) / resolution;
                    let y = canvas.height - (v.y - ymin) / resolution;
                    ctx.beginPath()
                    ctx.fillStyle = v.color;
                    ctx.strokeStyle = v.color
                    let font_size = (20 * (50 / resolution)).toFixed(0);
                    if (font_size < 1) {
                        font_size = 1;
                    }
                    ctx.font = font_size.toString() + 'px Arial';
                    ctx.textBaseline = "top";
                    ctx.fillText(v.name + "[" + v.battery + "%]", x, y, v.name.length * font_size);
                    // console.log(v);

                    let len = v.envelope.vertex.length
                    ctx.beginPath()
                    ctx.strokeStyle = v.color
                    for (let index = 0; index < len; index++) {
                        const element = v.envelope.vertex[index];
                        let s_x = (element.x + v.x - xmin) / resolution;
                        let s_y = canvas.height - (element.y + v.y - ymin) / resolution;
                        ctx.moveTo(s_x, s_y);
                        if (index == len - 1) {
                            let e_x = (v.envelope.vertex[0].x + v.x - xmin) / resolution;
                            let e_y = canvas.height - (v.envelope.vertex[0].y + v.y - ymin) / resolution;
                            ctx.lineTo(e_x, e_y);
                        } else {
                            let e_x = (v.envelope.vertex[index + 1].x + v.x - xmin) / resolution;
                            let e_y = canvas.height - (v.envelope.vertex[index + 1].y + v.y - ymin) / resolution;
                            ctx.lineTo(e_x, e_y);
                        }
                        ctx.lineWidth = 3;
                        ctx.stroke();
                    }
                    for (let step of v.step) {
                        let start = get_point(step["src"]);
                        let end = get_point(step["dest"]);
                        let ori = step["orientation"];
                        let start_x = (start.x - xmin) / resolution;
                        let start_y = canvas.height - (start.y - ymin) / resolution;
                        let end_x = (end.x - xmin) / resolution;
                        let end_y = canvas.height - (end.y - ymin) / resolution;
                        let len = Math.sqrt((end_x - start_x) * (end_x - start_x) + (end_y - start_y) * (end_y - start_y))
                        // console.log(len);
                        let norm_x = (end_x - start_x) / len;
                        let norm_y = (end_y - start_y) / len;
                        start_x = start_x + norm_x * 15;
                        start_y = start_y + norm_y * 15;
                        end_x = end_x - norm_x * 15;
                        end_y = end_y - norm_y * 15;
                        if (ori == "FORWARD") { drawArrowhead(ctx, start_x, start_y, end_x, end_y, 5 * (50 / resolution), v.color); }
                        else if (ori == "BACKWARD") { drawArrowhead(ctx, end_x, end_y, start_x, start_y, 5 * (50 / resolution), v.color); }
                    }
                    // console.log(v.destination);
                    if (v.destination != undefined) {
                        let loc = get_location(v.destination["dest"]);
                        let start_x = (loc.x - xmin) / resolution;
                        let start_y = canvas.height - (loc.y - ymin) / resolution;
                        let link = get_point(loc.link);
                        let link_x = (link.x - xmin) / resolution;
                        let link_y = canvas.height - (link.y - ymin) / resolution;
                        ctx.beginPath()
                        ctx.lineWidth = 4 * (50 / resolution);
                        if (ctx.lineWidth < 1) {
                            ctx.lineWidth = 1;
                        }
                        ctx.strokeStyle = '#ff0000'
                        ctx.moveTo(start_x + 5, start_y);
                        ctx.arc(start_x, start_y, 5, 0, 2 * Math.PI, true)
                        ctx.stroke()
                        ctx.strokeRect(start_x - 25 * (50 / resolution), start_y - 15 * (50 / resolution), 50 * (50 / resolution), 30 * (50 / resolution));
                        let len = Math.sqrt((link_x - start_x) * (link_x - start_x) + (link_y - start_y) * (link_y - start_y));
                        let norm_x = (link_x - start_x) / len;
                        let norm_y = (link_y - start_y) / len;
                        start_x = start_x + norm_x * 10 * (50 / resolution);
                        start_y = start_y + norm_y * 10 * (50 / resolution);
                        link_x = link_x - norm_x * 10 * (50 / resolution);
                        link_y = link_y - norm_y * 10 * (50 / resolution);
                        ctx.beginPath()
                        ctx.strokeStyle = '#909090'
                        ctx.moveTo(start_x, start_y);
                        ctx.lineTo(link_x, link_y)
                        ctx.stroke()
                    }
                }
            }
        }
        function clicked() {
            get_model();
        }
        function stop_() {
            if (is_running) {
                is_running = false
                clearInterval(timer_draw_vehlice);
                document.getElementById('stop_btn').style.display = 'none';
                document.getElementById('ok_btn').style.display = '';
                document.getElementById('ip_btn').removeAttribute('disabled')
            }
        }

        function file_read() {
            const ele = document.getElementById('model_file')
            let file = ele.files[0];
            // console.log(file)
            const filereader = new FileReader()
            filereader.onload = (e) => {
                let xml = filereader.result;
                let parser = new DOMParser();
                let xmlDoc = parser.parseFromString(xml, "text/xml");
                // console.log(xmlDoc)
                let http = new XMLHttpRequest();
                let ip = document.getElementById("ip_btn").value;
                http.open("PUT", "http://" + ip + "/v1/plantModel?type=xml", true);
                http.onload = function () {
                    if (http.readyState == 4 && http.status == 200) {
                        // console.log("send order ok");
                        clicked()
                    }
                    else {
                        console.log("send order err");
                    }
                }
                http.send(xmlDoc)
                ele.value = ""
            }
            filereader.readAsText(file)
        }
    </script>
</head>


<body onload="start()">
    <div class="main">
        <div class="ip">
            <input type="text" id="ip_btn" class="label" value="127.0.0.1:55200" placeholder="服务器地址：端口号">
        </div>
        <div>
            <button class="button" id="ok_btn" onclick="clicked()">确定</button>
            <button class="button" id="stop_btn" onclick="stop_()">停止</button>
            <span class="upload-file">
                <input type="file" class="input-file" accept=".xml" id="model_file" onchange="file_read()">
                <span class="tip">选择模型文件</span>
            </span>
        </div>


        <div class="view">
            <canvas id="map" width="400" height="800">
            </canvas>
            <canvas id="Order" width="400" height="800">
            </canvas>
            <canvas id="Vehicle" width="400" height="800">
            </canvas>
        </div>
    </div>
</body>
<style type="text/css">
    body {
        background: #ffffff;
        height: 100%;
    }

    div {
        position: relative;
        padding: 7px;
        text-align: center;
    }

    .label {
        padding: 10px;
        color: #2c80e7;
        font-size: 20px;
        border-top: none;
        border-left: none;
        border-right: none;
        border-bottom-width: 5px;
        border-bottom-color: #58a689;
        outline: none;
        text-align: center;
        /* background-color: #58a689; */
        /* background-color: #b4e3c6; */
    }

    .ip input {
        filter: alpha(opacity=0);
        cursor: text;
    }

    .ip input:hover {
        border-top: none;
        border-left: none;
        border-right: none;
        border-bottom-width: 5px;
        border-bottom-color: #c2324a;
    }

    .label::placeholder {
        color: rgb(86, 132, 151);
    }

    .button {
        background-color: #58a689;
        border: none;
        color: white;
        padding: 10px;
        text-align: center;
        text-decoration: none;
        display: inline-block;
        font-size: 20px;
    }

    .button:hover {
        background-color: #e40f00;
        font-size: 21px;

    }

    .button:disabled {
        background-color: gray;
    }


    #map {
        position: absolute;
        left: 0px;
        top: 0px;
        margin: 20px;
        background: #ffffff;
        border: thin solid #1b7cdd;
    }

    #Order {
        position: absolute;
        left: 0px;
        top: 0px;
        margin: 20px;
        border: thin solid #1b7cdd;
    }

    #Vehicle {
        position: absolute;
        left: 0px;
        top: 0px;
        margin: 20px;
        border: thin solid #1b7cdd;
    }

    .upload-file {
        position: relative;
        width: 100px;
        padding: 10px 15px;
        border: 1px solid rgb(119, 154, 80);
        /* border-radius: 5px; */
        background-color: #58a689;
        color: #fffefe;
        font-size: 24px;
        text-align: center;
        overflow: hidden;
    }

    .upload-file span {
        text-overflow: ellipsis;
        white-space: nowrap;
        overflow: hidden;
    }

    .upload-file:hover {
        font-size: 25px;
        border-color: rgb(39, 226, 81);
        background-color: #c22439;

    }


    .upload-file input[type='file'] {
        height: 100%;
        width: 100%;
        position: absolute;
        top: 0;
        right: 0;
        opacity: 0;
        filter: alpha(opacity=0);
        cursor: pointer;
    }
</style>

</html>